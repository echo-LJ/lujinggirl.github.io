<!DOCTYPE html>
<html lang>
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Echo">



    <meta name="description" content="blog">



<title>前端工程化 | Echo的博客</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


</head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Echo&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Echo&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">前端工程化</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Echo</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">March 1, 2018&nbsp;&nbsp;10:00:00</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <meta name="referrer" content="no-referrer">

<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>web应用复杂度的增加，特别是单页面应用的风靡。组件化，工程化，自动化成了前端发展的趋势。<br>每个前端团队都在打造自己的前端开发体系，这通常是一个东拼西凑，逐渐磨合的过程，在技术发展日新月异的今天，这样的过程真的是不可抽象和复制的么？通过拆解前端开发体系,对前端工程化有所理解。</p>
<h1 id="I-前端工程化"><a href="#I-前端工程化" class="headerlink" title="I. 前端工程化"></a>I. 前端工程化</h1><hr>
<p>前端工程本质上是软件工程的一种。软件工程化关注的是性能、稳定性、可用性、可维护性等方面，注重基本的开发效率、运行效率的同时，思考维护效率。一切以这些为目标的工作都是”前端工程化”。</p>
<h6 id="前端工程化面临的问题"><a href="#前端工程化面临的问题" class="headerlink" title="前端工程化面临的问题 ?"></a>前端工程化面临的问题 ?</h6><ol>
<li><p>开发成本<br>大体量：多功能、多页面、多状态、多系统；<br>大规模：多人甚至多团队合作开发；</p>
<ul>
<li>提高开发生产效率</li>
<li>降低维护难度</li>
</ul>
</li>
</ol>
<p>这两个问题的解决方案有两点：</p>
<ul>
<li>制定开发规范，提高团队协作能力；</li>
<li>分治。软件工程中有个很重要的概念叫做<code>模块化开发</code>其中心思想就是分治。<ol start="2">
<li>部署<br>从部署角度，要解决的问题主要是资源管理，包括：</li>
</ol>
</li>
<li>代码审查</li>
<li>压缩打包</li>
<li>增量更新</li>
<li>单元测试</li>
</ul>
<ol start="3">
<li>高性能<br>CDN 部署、缓存控制、文件指纹、缓存复用、请求合并、按需加载、同步/异步加载、移动端首屏 CSS 内嵌、HTTP 2.0 服务端资源推送。<h6 id="如何做”前端工程化”？"><a href="#如何做”前端工程化”？" class="headerlink" title="如何做”前端工程化”？"></a>如何做”前端工程化”？</h6>前端工程化就是为了让前端开发能够“自成体系”，个人认为主要应该从模块化、组件化、规范化、自动化四个方面思考。</li>
</ol>
<h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><hr>
<blockquote>
<p>简单来说，模块化就是将一个大文件拆分成相互依赖的小文件，再进行统一的拼装和加载。</p>
</blockquote>
<h6 id="JS的模块化"><a href="#JS的模块化" class="headerlink" title="JS的模块化"></a>JS的模块化</h6><p>在ES6之前，JavaScript一直没有模块系统，这对开发大型复杂的前端工程造成了巨大的障碍。对此社区制定了一些模块加载方案，如CommonJS、AMD和CMD等。<br>现在ES6已经在语言层面上规定了模块系统，完全可以取代现有的CommonJS和AMD规范，而且使用起来相当简洁，并且有静态加载的特性。</p>
<ul>
<li>用 Webpack + Babel 将所有模块打包成一个文件同步加载，也可以搭乘多个chunk异步加载；</li>
<li>用 System+Babel 主要是分模块异步加载；</li>
<li>用浏览器的<code>&lt;script type=&quot;module&quot;&gt;</code>加载。<h6 id="CSS的模块化"><a href="#CSS的模块化" class="headerlink" title="CSS的模块化"></a>CSS的模块化</h6>虽然SASS、LESS、Stylus等预处理器实现了CSS的文件拆分，但没有解决CSS模块化的一个重要问题：选择器的全局污染问题。</li>
</ul>
<p>按道理，一个模块化的文件应该要隐藏内部作用域，只暴露少量接口给使用者。而按照目前预处理器的方式，导入一个CSS模块后，已存在的样式有被覆盖的风险。虽然重写样式是CSS的一个优势，但这并不利于多人协作。</p>
<p>为了避免全局选择器的冲突，需要制定CSS命名风格：</p>
<ul>
<li>BEM风格</li>
<li>Bootstrap风格</li>
<li>团队CSS规范</li>
</ul>
<p>但是这毕竟是弱约束。所以很赞同一句话：</p>
<blockquote>
<p>与其费尽心思地告诉别人要遵守某种规则，以规避某种痛苦，倒不如从工具层面就消灭这种痛苦。</p>
</blockquote>
<p>从工具层面，社区又创造出<code>Shadow DOM</code>、<code>CSS in JS</code>和<code>CSS Modules</code>三种解决方案。</p>
<ul>
<li>Shadow DOM是WebComponents的标准。它能解决全局污染问题，但目前很多浏览器不兼容，对我们来说还很久远；</li>
<li>CSS in JS是彻底抛弃CSS，使用JS或JSON来写样式。这种方法很激进，不能利用现有的CSS技术，而且处理伪类等问题比较困难；</li>
<li>CSS Modules仍然使用CSS，只是让JS来管理依赖。它能够最大化地结合CSS生态和JS模块化能力，目前来看是最好的解决方案。Vue的<code>scoped</code> style也算是一种。<h6 id="资源的模块化"><a href="#资源的模块化" class="headerlink" title="资源的模块化"></a>资源的模块化</h6>Webpack的强大之处不仅仅在于它统一了JS的各种模块系统，取代了Browserify、RequireJS、SeaJS的工作。更重要的是它的万能模块加载理念，即所有的资源都可以且也应该模块化。</li>
<li><code>依赖关系单一化</code>。所有CSS和图片等资源的依赖关系统一走JS路线，无需额外处理CSS预处理器的依赖关系，也不需处理代码迁移时的图片合并、字体图片等路径问题；</li>
<li><code>资源处理集成化</code>。现在可以用loader对各种资源做各种事情，比如复杂的vue-loader等等；</li>
<li><code>项目结构清晰化</code>。使用Webpack后，你的项目结构总可以表示成这样的函数： <code>dest = webpack(src, config)</code>。<h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3></li>
</ul>
<hr>
<p>从UI拆分下来的每个包含模板(HTML)+样式(CSS)+逻辑(JS)功能完备的结构单元，我们称之为组件。</p>
<blockquote>
<p><code>组件化≠模块化</code>。模块化只是在文件层面上，对代码或资源的拆分；而组件化是在设计层面上，对UI（用户界面）的拆分。</p>
</blockquote>
<p>随着 web 应用规模越来越大，模块/组件化开发的需求就显得越来越迫切。模块/组件化开发的核心思想是分治，主要针对的是开发和维护阶段。</p>
<ol>
<li>Web 应用的组件化开发。<a href="http://blog.jobbole.com/56161/" target="_blank" rel="noopener">http://blog.jobbole.com/56161/</a></li>
<li>前端组件化开发实践。<a href="http://web.jobbole.com/82689/" target="_blank" rel="noopener">http://web.jobbole.com/82689/</a></li>
<li>大规模的前端组件化与模块化。<a href="http://www.infoq.com/cn/news/2014/04/front-end-modular" target="_blank" rel="noopener">http://www.infoq.com/cn/news/…</a></li>
</ol>
<h6 id="为什么搭建私有组件库"><a href="#为什么搭建私有组件库" class="headerlink" title="为什么搭建私有组件库?"></a>为什么搭建私有组件库?</h6><ul>
<li>可复用 跨项目可以使用同一套私有组件库</li>
<li>方便维护 如需组件调整 只需要修改组件库 不需要跨项目重复修改</li>
</ul>
<h5 id="添加新组件原则"><a href="#添加新组件原则" class="headerlink" title="添加新组件原则"></a>添加新组件原则</h5><ul>
<li>组件应先存在于具体项目中，经过重复验证后再抽象、沉淀到本组件库中</li>
<li>Vue component 只应负责渲染数据和内部逻辑，尽可能不包含 &dollar;t 国际化、ajax 请求等业务数据和逻辑</li>
<li>组件和其他模块应尽可能的搭配单元测试、可运行的 storybook 例子</li>
<li>应该在 CHANGELOG 中记录每次增删改的组件信息等</li>
</ul>
<h3 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h3><hr>
<p>规范化其实是工程化中很重要的一个部分，项目初期规范制定的好坏会直接影响到后期的开发质量。</p>
<p>比如：</p>
<ul>
<li>######目录结构的制定</li>
<li>######编码规范<br>  制定一套良好的编码规范可以增强团队开发协作、提高代码质量。<br><code>推荐参考</code><br><strong>凹凸实验室</strong>打造的<a href="https://guide.aotu.io/docs/index.html" target="_blank" rel="noopener">前端代码规范</a>。<br><strong>Javascript Airbnb</strong> 开发规范 <a href="https://github.com/airbnb/javascript" target="_blank" rel="noopener">https://github.com/airbnb/jav…</a><ul>
<li>HTML规范</li>
<li>CSS规范</li>
<li>JS规范</li>
<li>图片规范</li>
<li>命名规范</li>
</ul>
</li>
<li><p>######前后端接口规范<br>“基于 Ajax 带来的 SPA 时代”，这种模式下，前后端的分工非常清晰，前后端的关键协作点是 Ajax 接口，引发一个重要问题：前后端的对接界面双方却关注甚少，没有任何接口约定规范情况下各自撸起袖子就是干，导致我们在产品项目开发过程中，前后端的接口联调对接工作量占比在30%-50%左右，甚至会更高。往往前后端接口联调对接及系统间的联调对接都是整个产品项目研发的软肋。</p>
<p>接口规范主要初衷就是规范约定先行，尽量避免沟通联调产生的不必要的问题，让大家身心愉快地专注于各自擅长的领域。</p>
</li>
<li><h6 id="文档规范"><a href="#文档规范" class="headerlink" title="文档规范"></a>文档规范</h6></li>
<li><h6 id="组件管理"><a href="#组件管理" class="headerlink" title="组件管理"></a>组件管理</h6></li>
<li><h6 id="git分支管理"><a href="#git分支管理" class="headerlink" title="git分支管理"></a>git分支管理</h6></li>
<li><h6 id="commit描述规范"><a href="#commit描述规范" class="headerlink" title="commit描述规范"></a>commit描述规范</h6></li>
<li><h6 id="定期-CodeReview"><a href="#定期-CodeReview" class="headerlink" title="定期 CodeReview"></a>定期 CodeReview</h6></li>
</ul>
<h3 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h3><hr>
<p>   前端工程化的很多脏活累活都应该交给自动化工具来完成。需要秉持的一个理念是:</p>
<blockquote>
<p>任何简单机械的重复劳动都应该让机器去完成。</p>
</blockquote>
<ul>
<li><p>图标合并</p>
</li>
<li><p>持续继承</p>
</li>
<li><p>自动化构建</p>
</li>
<li><p>自动化部署</p>
</li>
<li><p>自动化测试</p>
</li>
</ul>
<h1 id="II-工程化具体方法"><a href="#II-工程化具体方法" class="headerlink" title="II. 工程化具体方法"></a>II. 工程化具体方法</h1><hr>
<h2 id="1-性能优化"><a href="#1-性能优化" class="headerlink" title="1. 性能优化"></a>1. 性能优化</h2><p>浏览器缓存是 Web 性能优化的重要方式。那么浏览器缓存的过程究竟是怎么样的呢？</p>
<p>浏览器缓存主要分为<code>强强缓存（也称本地缓存）</code>和<code>协商缓存（也称弱缓存）</code>。</p>
<p> ######强缓存</p>
<ul>
<li><p>Expires 是 http1.0 的规范，它的值是一个绝对时间的 GMT 格式的时间字符串。如我现在这个网页的 Expires 值是：expires:Fri, 14 Apr 2017 10:47:02 GMT。这个时间代表这这个资源的失效时间，只要发送请求时间是在 Expires 之前，那么本地缓存始终有效，则在缓存中读取数据。所以这种方式有一个明显的缺点，由于失效的时间是一个绝对时间，所以当服务器与客户端时间偏差较大时，就会导致缓存混乱。如果同时出现 Cache-Control:max-age 和 Expires，那么 max-age 优先级更高。</p>
<ul>
<li>Cache-Control 是在 http1.1 中出现的，主要是利用该字段的 max-age 值来进行判断，它是一个相对时间，例如 Cache-Control:max-age=3600，代表着资源的有效期是 3600 秒。cache-control 除了该字段外，还有下面几个比较常用的设置值：</li>
</ul>
<p>no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在 ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。</p>
<p>no-store：直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。</p>
<p>public：可以被所有的用户缓存，包括终端用户和 CDN 等中间代理服务器。<br>private：只能被终端用户的浏览器缓存，不允许 CDN 等中继缓存服务器对其缓存。<br>Cache-Control 与 Expires 可以在服务端配置同时启用，同时启用的时候   Cache-Control 优先级高。<br>######弱缓存/协商缓存<br><strong>Etag 和 If-None-Match</strong></p>
</li>
</ul>
<p>Etag/If-None-Match 返回的是一个校验码。ETag 可以保证每一个资源是唯一的，资源变化都会导致 ETag 变化。服务器根据浏览器上送的 If-None-Match 值来判断是否命中缓存</p>
<p>与 Last-Modified 不一样的是，当服务器返回 304 Not Modified 的响应时，由于 ETag 重新生成过，response header 中还会把这个 ETag 返回，即使这个 ETag 跟之前的没有变化。</p>
<p><strong>Last-Modify/If-Modify-Since</strong></p>
<p>浏览器第一次请求一个资源的时候，服务器返回的 header 中会加上 Last-Modify，Last-modify 是一个时间标识该资源的最后修改时间，例如 Last-Modify: Thu,31 Dec 2037 23:59:59 GMT。</p>
<p>当浏览器再次请求该资源时，request 的请求头中会包含 If-Modify-Since，该值为缓存之前返回的 Last-Modify。服务器收到 If-Modify-Since 后，根据资源的最后修改时间判断是否命中缓存。</p>
<p>如果命中缓存，则返回 304，并且不会返回资源内容，并且不会返回 Last-Modify。</p>
<p>Last-Modified 与 ETag 是可以一起使用的，服务器会优先验证 ETag</p>
<hr>
<p><img src="https://upload-images.jianshu.io/upload_images/11846892-c4678e7b6821f8b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<hr>
<p><img src="https://upload-images.jianshu.io/upload_images/11846892-4c9053e0fd74c93f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h4 id="访问量和性能指标"><a href="#访问量和性能指标" class="headerlink" title="访问量和性能指标"></a>访问量和性能指标</h4><p>a.css 的请求，如果每次用户访问页面都要加载，很影响性能，很浪费带宽</p>
<p><img src="https://upload-images.jianshu.io/upload_images/11846892-41104d7c231d27e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<hr>
<p>利用 304，让浏览器使用本地缓存。304 叫协商缓存，这玩意还是要和服务器通信一次，我们的优化级别是变态级，所以必须彻底灭掉这个请求，变成这样：<br><img src="https://upload-images.jianshu.io/upload_images/11846892-2fd0094493df3b08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>强制浏览器使用本地缓存（cache-control/expires），不要和服务器通信。好了，请求方面的优化已经达到变态级别，那问题来了：你都不让浏览器发资源请求了，这缓存咋更新？</p>
<p>很好，相信有人想到了办法：通过<code>更新页面中引用的资源路径，让浏览器主动放弃缓存，加载新资源</code>。好像这样：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/11846892-577a64c93602bf2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="`"></p>
<p>页面引用了 3 个 css，而某次上线只改了其中的 a.css，如果所有链接都更新版本，就会导致 b.css，c.css 的缓存也失效，那岂不是又有浪费了？！</p>
<p><img src="https://upload-images.jianshu.io/upload_images/11846892-c3a7badbd331fd6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>重新开启变态模式，我们不难发现，要解决这种问题，必须让 url 的修改与文件内容关联，也就是说，只有文件内容变化，才会导致相应 url 的变更，从而实现文件级别的精确缓存控制。</p>
<p>什么东西与文件内容相关呢？我们会很自然的联想到利用  <code>数据摘要算法</code> 对文件求摘要信息，摘要信息与文件内容一一对应，就有了一种可以精确到单个文件粒度的缓存控制依据了。好了，我们把 url 改成带摘要信息的：<br><img src="https://upload-images.jianshu.io/upload_images/11846892-027cf303a23fc22f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>现代互联网企业，为了进一步提升网站性能，会把静态资源和动态网页分集群部署，静态资源会被部署到 CDN 节点上，网页中引用的资源也会变成对应的部署路径：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/11846892-ae5c4239f5b12df1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>这次发布，同时改了页面结构和样式，也更新了静态资源对应的 url 地址，现在要发布代码上线，亲爱的前端研发同学，你来告诉我，咱们是先上线页面，还是先上线静态资源？</p>
<p><img src="https://upload-images.jianshu.io/upload_images/11846892-f05ceb812e53f51c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li><strong>先部署页面，再部署资源</strong>：在二者部署的时间间隔内，如果有用户访问页面，就会在新的页面结构中加载旧的资源，并且把这个旧版本的资源当做新版本缓存起来，其结果就是：用户访问到了一个样式错乱的页面，除非手动刷新，否则在资源缓存过期之前，页面会一直执行错误。</li>
<li><strong>先部署资源，再部署页面</strong>：在部署时间间隔之内，有旧版本资源本地缓存的用户访问网站，由于请求的页面是旧版本的，资源引用没有改变，浏览器将直接使用本地缓存，这种情况下页面展现正常；但没有本地缓存或者缓存过期的用户访问网站，就会出现旧版本页面加载新版本资源的情况，导致页面执行错误，但当页面完成部署，这部分用户再次访问页面又会恢复正常了。</li>
</ul>
<hr>
<p>好的，上面一坨分析想说的就是：先部署谁都不成！都会导致部署过程中发生页面错乱的问题。所以，访问量不大的项目，可以让研发同学苦逼一把，等到半夜偷偷上线，先上静态资源，再部署页面，看起来问题少一些。<br>有些公司超变态，没有这样的“绝对低峰期”，只有“相对低峰期”。So，为了稳定的服务，还得继续追求极致啊！</p>
<p>这个奇葩问题，起源于资源的 覆盖式发布，用 待发布资源 覆盖 已发布资源，就有这种问题。解决它也好办，就是实现 非覆盖式发布。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/11846892-3f21dab466192813.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>看上图，用文件的摘要信息来对资源文件进行重命名，把摘要信息放到资源文件发布路径中，这样，内容有修改的资源就变成了一个新的文件发布到线上，不会覆盖已有的资源文件。上线过程中，先全量部署静态资源，再灰度部署页面，整个问题就比较完美的解决了。</p>
<hr>
<p>所以，静态资源优化方案，基本上要实现这么几个东西：</p>
<p>配置超长时间的本地缓存 —— 节省带宽，提高性能<br>采用内容摘要作为缓存更新依据 —— 精确的缓存控制<br>静态资源 CDN 部署 —— 优化网络请求<br>更资源发布路径实现非覆盖式发布 —— 平滑升级</p>
<h2 id="总之，前端性能优化绝逼是一个工程问题！"><a href="#总之，前端性能优化绝逼是一个工程问题！" class="headerlink" title="总之，前端性能优化绝逼是一个工程问题！"></a>总之，前端性能优化绝逼是一个工程问题！</h2><h2 id="2-静态资源部署-CDN"><a href="#2-静态资源部署-CDN" class="headerlink" title="2. 静态资源部署 CDN"></a>2. 静态资源部署 CDN</h2><p>CDN[Content Delivery Network] 内容分发网络 主要功能是在不同的地点缓存内容，通过负载均衡技术，将用户的请求定向到最合适的缓存服务器上去获取内容<br><img src="https://upload-images.jianshu.io/upload_images/11846892-80610fe2d3c9090e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>总结一下 CDN 的工作原理：通过权威 DNS 服务器来实现最优节点的选择，通过缓存来减少源站的压力。</p>
<hr>
<p>CDN 应用场景：</p>
<p>静态网页<br>图片小文件、博客<br>大文件下载<br>软件下载、视频点播或图片存储网站<br>动态加速<br>直播网站<br>应用加速<br>手机 APP<br>除却 CDN 自身的优势，在前端工程中，将静态文件放到 CDN 上，可以直观地减小资源包大小，同时加快首屏加载。</p>
<p>若不使用 CDN，则所有的资源都会被打包到 app.js 和 vendor.js 中，页面需要等到这两个包下载完成才可以显示。<br>若使用 CDN，则可以利用浏览器多线程的优势，同时下载若干静态文件以及剩下的 app.js 和 vendor.js，以此达到加快加载的目的。</p>
<hr>
<h3 id="3-自动化文档生成"><a href="#3-自动化文档生成" class="headerlink" title="3. 自动化文档生成"></a>3. 自动化文档生成</h3><p><code>commit message</code> 作用</p>
<ul>
<li>提供更多的历史信息，方便快速浏览</li>
<li>过滤某些 commit（比如文档改动），便于快速查找信息</li>
<li>直接从 commit 生成 Change log</li>
<li>可读性好，清晰，不必深入看代码即可了解当前 commit 的作用。</li>
<li>为 Code Reviewing（代码审查）做准备</li>
<li>方便跟踪工程历史</li>
<li>提高项目的整体质量，提高个人工程素质</li>
</ul>
<p>目前，社区有多种 Commit message 的写法规范，我们介绍的工具是 commitizen，它使用的是 Angular 规范<a href="https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit#heading=h.greljkmo14y0" target="_blank" rel="noopener">AngularJS Git Commit Message Conventions</a>，这是目前使用最广的写法，并且有对应的工具去生成 change log。</p>
<p><strong>标准说明</strong></p>
<p>每次提交， Commit message 都包括 Header, Body 和 Footer 三个部分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br><span class="line">// 空行</span><br><span class="line">&lt;body&gt;</span><br><span class="line">// 空行</span><br><span class="line">&lt;footer&gt;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>Header</strong> 部分只有一行，包括三个字段：type, scope 和 subject 。<br>type 用于说明提交的类别，只运行使用下面几种，</p>
<ul>
<li>feat: 新功能</li>
<li>fix: 修复 bug</li>
<li>docs: 仅仅修改了文档，比如 README, CHANGELOG, CONTRIBUTE 等等</li>
<li>style: 格式更新（不影响代码运行的变动）</li>
<li>refactor: 重构（既不是新增功能，又不是 bug 修复）</li>
<li>test: 添加测试</li>
<li>chore: 构建过程或辅助工具的变动</li>
<li>perf: 优化相关，比如提升性能、体验</li>
<li>revert: 回滚到上一个版本</li>
<li>ci：自动化流程配置修改</li>
</ul>
<p>如果是 feat 和 fix ，则这个 commit 将肯定出现在 change log 中，其它情况可自行决定是否放入。</p>
<p>scope 用于说明 commit 影响的范围 比如数据层、控制层、视图层等等，视项目不同而不同。</p>
<p>subject 是 commit 目的的简短描述，不超过 50 个字符。</p>
<ul>
<li>以动词开头，使用第一人称现在时，比如 change，而不是 changed 或 changes</li>
<li>第一个字母小写</li>
<li>结尾不要加句号</li>
</ul>
<hr>
<p><strong>Body</strong> 部分是对本次 commit 的详细描述，可分成多行。但是一般我都不写。</p>
<p><strong>Footer</strong> 部分只用于两种情况。</p>
<p>不兼容变动</p>
<p>如果当前代码与上一个版本不兼容，则 Footer 部分以 BREAKING CHANGE 开头，后面是对变动的描述、以及变动理由和迁移方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">BREAKING CHANGE: isolate scope bindings definition has changed.</span><br><span class="line"></span><br><span class="line">    To migrate the code follow the example below:</span><br><span class="line"></span><br><span class="line">    Before:</span><br><span class="line"></span><br><span class="line">    scope: &#123;</span><br><span class="line">      myAttr: &apos;attribute&apos;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    After:</span><br><span class="line"></span><br><span class="line">    scope: &#123;</span><br><span class="line">      myAttr: &apos;@&apos;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    The removed `inject` wasn&apos;t generaly useful for directives so there should be no code using it.</span><br></pre></td></tr></table></figure>
<hr>
<p>关闭 Issue<br>如果当前 commit 针对某个 issue ，那么可以在 Footer 部分关闭这个 issue 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Closes #1234</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Closes #1234, $1235, #1236</span><br></pre></td></tr></table></figure>
<p><strong>Revert</strong></p>
<p>如果当前 commit 用于撤销以前的 commit，则必须以 revert:开头，后面跟着被撤销 Commit 的 Header</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">revert: feat(pencil): add &apos;graphiteWidth&apos; option</span><br><span class="line">&lt;br /&gt;</span><br><span class="line">This reverts commit 667ecc1654a317a13331b17617d973392f415f02.</span><br></pre></td></tr></table></figure>
<ul>
<li>Body 部分的格式是固定的，必须写成 This reverts commit .，其中的 hash 是被撤销 commit 的 SHA 标识符。</li>
<li>如果当前 commit 与被撤销的 commit，在同一个发布（release）里面，那么它们都不会出现在 Change log 里面。如果两者在不同的发布，那么当前 commit，会出现在 Change log 的 Reverts 小标题下面。</li>
</ul>
<hr>
<h5 id="自动生成-changelog-文档"><a href="#自动生成-changelog-文档" class="headerlink" title="自动生成 changelog 文档"></a>自动生成 changelog 文档</h5><h6 id="commitizen"><a href="#commitizen" class="headerlink" title="commitizen"></a>commitizen</h6><p>Commitizen 是一个撰写合格 Commit message 的工具。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g commitizen</span><br><span class="line"># 在项目目录里，运行下面的命令，使其支持 Angular 的 Commit message 格式。</span><br><span class="line">commitizen init cz-conventional-changelog --save --save-exact</span><br></pre></td></tr></table></figure>
<p>用 git cz -m 代替 git commit -m 就可以轻松的写出 Angular 规范的 commit message 了。</p>
<h6 id="validate-commit-msg"><a href="#validate-commit-msg" class="headerlink" title="validate-commit-msg"></a>validate-commit-msg</h6><p>用于检查 Node 项目的 Commit message 是否符合格式。</p>
<h6 id="conventional-changelog"><a href="#conventional-changelog" class="headerlink" title="conventional-changelog"></a>conventional-changelog</h6><p>生成 Change log 的工具，运行下面的命令即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g conventional-changelog-cli</span><br><span class="line">cd my-project</span><br><span class="line">conventional-changelog -p angular -i CHANGELOG.md -s</span><br></pre></td></tr></table></figure>
<hr>
<p>如果你的所有 Commit 都符合 Angular 格式，那么发布新版本时， Change log 就可以用脚本自动生成</p>
<p>生成的文档包括以下三个部分。</p>
<ul>
<li>New features</li>
<li>Bug fixes</li>
<li>Breaking changes.</li>
</ul>
<p>每个部分都会罗列相关的 commit ，并且有指向这些 commit 的链接。当然，生成的文档允许手动修改，所以发布前，你还可以添加其他内容。</p>
<p>为了方便使用，可以将其写入 package.json 的 scripts 字段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;changelog&quot;: &quot;conventional-changelog -p angular -i CHANGELOG.md -w -r 0&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run changelog</span><br></pre></td></tr></table></figure>
<h3 id="4-前端埋点"><a href="#4-前端埋点" class="headerlink" title="4. 前端埋点"></a>4. 前端埋点</h3><p><strong>目的</strong><br>获取用户基本信息、行为以及跟踪产品在用户端的使用情况，并以监控数据为基础，指明产品优化的方向。<br><strong>前端监控类别</strong><br>前端监控可以分为三类：数据监控、性能监控和异常监控。<br><code>数据监控</code>就是监听用户信息和行为，常见的监控项有</p>
<p>*PV(page view 页面访问量)：即页面浏览量或点击量</p>
<ul>
<li>UV(unique visitor 独立访客)：指访问某个站点或点击某条新闻的不同 IP 地址的人数</li>
<li>用户在每一个页面的停留时间</li>
<li>用户通过什么入口来访问该网页</li>
<li>用户在相应的页面中触发的行为<br>统计这些数据是有意义的，比如我们知道了用户来源的渠道，可以促进产品的推广，知道用户在每一个页面停留的时间，可以针对停留较长的页面，增加广告推送等等。</li>
</ul>
<p><code>性能监控</code>指的是监听前端的性能，主要包括监听网页或者说产品在用户端的体验。常见的性能监控项包括：</p>
<ul>
<li>不同用户，不同机型和不同系统下的首屏加载时间</li>
<li>http 等请求的响应时间</li>
<li>静态资源整体下载时间</li>
<li>页面渲染时间</li>
<li>页面交互动画完成时间<br>这些性能监控的结果，可以展示前端性能的好坏，根据性能监测的结果可以进一步的去优化前端性能，比如兼容低版本浏览器的动画效果，加快首屏加载等等。</li>
</ul>
<p><code>异常监控</code>由于产品的前端代码在执行过程中也会发生异常，因此需要引入异常监控。及时的上报异常情况，可以避免线上故障的发上。虽然大部分异常可以通过 try catch 的方式捕获，但是比如内存泄漏以及其他偶现的异常难以捕获。常见的需要监控的异常包括：</p>
<ul>
<li>Javascript 的异常监控</li>
<li>样式丢失的异常监控</li>
<li>服务器请求的异常监控<br>我们说完了前端监控的三个分类，现在就来聊聊怎么实现前端监控。实现前端监控，第一步肯定是将我们要监控的事项（数据）给收集起来，再提交给后台，最后进行数据分析。数据收集的丰富性和准确性会直接影响到我们做前端监控的质量，因为我们会以此为基础，为产品的未来发展指引方向。</li>
</ul>
<hr>
<p>#####前端埋点分类</p>
<p>收集监控数据我们是通过前端埋点来实现的，目前常见的前端埋点方法有三种：<code></code>手动埋点<code>、</code>可视化埋点<code>和</code>无埋点`。<br><strong>手动埋点</strong>，也叫代码埋点，即纯手动写代码，调用埋点 SDK 的函数，在需要埋点的业务逻辑功能位置调用接口，上报埋点数据，像友盟、百度统计等第三方数据统计服务商大都采用这种方案。<br>优势:</p>
<ul>
<li>可自定义属性，自定义事件<ul>
<li>可以细化需求</li>
<li>相比其他埋点方式减少服务器压力</li>
</ul>
</li>
</ul>
<p>缺陷:</p>
<ul>
<li>工程量大的话，手动埋点会出现疏漏，不方便审查。</li>
<li>需求变更要重新埋点，成本高。</li>
<li>每次需求变更都要重新发布版本，对线上系统稳定性有一定危害</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(document).ready(() =&gt; &#123;</span><br><span class="line">  // ... 这里是你的业务逻辑代码</span><br><span class="line">  sendData(params) //这里是发送你的埋点数据，params是你封装的埋点数据</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>前端框架式手动埋点</strong></p>
<p>如果使用 Vue 或者 React 等前端框架，这些框架都有自己的各种生命周期，为了减少重复性的手动埋点次数，可以在各个生命周期位置，根据你的需求封装你所需的埋点。比如你是 SPA 单页应用，你希望在每一个页面的 componentDidMount 埋点，并由此确定用户已经打开了页面。</p>
<p>css 埋点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.link:active::after &#123;</span><br><span class="line">  content: url(&apos;http://www.example.com?action=yourdata&apos;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;a class=&quot;link&quot;&gt;点击我，会发埋点数据&lt;/a&gt;</span><br></pre></td></tr></table></figure></p>
<hr>
<p><strong>可视化埋点</strong>解决了纯手动埋点的开发成本和更新成本，通过可视化工具快速配置采集节点（圈点），在前端自动解析配置，并根据配置上传埋点数据，比起手动埋点看起来更无痕，</p>
<p>比如国外比较早做可视化的是 Mixpanel，国内较早支持可视化埋点的有 TalkingData、诸葛 IO，2017 年腾讯的 MTA 也宣布支持可视化埋点；</p>
<hr>
<p><strong>无埋点</strong>则是前端自动采集全部事件，上报埋点数据，由后端来过滤和计算出有用的数据。</p>
<p>优点:<br>前端只要一次加载埋点脚本</p>
<p>缺点:<br>服务器性能压力山大</p>
<p>采用无埋点技术的有主流的 GrowingIO、神策。无埋点则是前端自动采集全部事件，上报埋点数据，由后端来过滤和计算出有用的数据。</p>
<h2 id="VI-总结"><a href="#VI-总结" class="headerlink" title="#VI. 总结"></a>#VI. 总结</h2><p>在业界内有这么一句话：任何简单机械的重复劳动都应该让机器去完成。现代前端技术不再是以前刀耕火种的年代了。所以前端工程化的很多脏活累活都应该交给自动化工具来完成。</p>
<p>如何选型技术、如何定制规范、如何分治系统、如何优化性能、如何加载资源，当你从切图开始转变为思考这些问题的时候，我想说：</p>
<h2 id="你好，工程师！"><a href="#你好，工程师！" class="headerlink" title="你好，工程师！"></a>你好，工程师！</h2><p>总结：大功告成✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️</p>
<p>参考链接：</p>
<ol>
<li><a href="https://www.jianshu.com/p/88ed70476adb" target="_blank" rel="noopener">前端工程化的理解</a></li>
<li><a href="[https://www.zhihu.com/question/20790576/answer/32602154]">大公司里怎样开发和部署前端代码？</a></li>
<li><a href="http://www.imooc.com/article/27151" target="_blank" rel="noopener">前端埋点的那些事</a></li>
<li><a href="https://www.jianshu.com/p/645a26619508" target="_blank" rel="noopener">小谈前端埋点</a></li>
<li><a href="https://github.com/fouber/blog/issues/10" target="_blank" rel="noopener">前端工程——基础篇</a></li>
<li><a href="https://www.jianshu.com/p/a248b146c55a" target="_blank" rel="noopener">http-proxy-middleware</a></li>
<li><a href="https://www.jianshu.com/p/3bdff821f859" target="_blank" rel="noopener">Webpack dev server 使用 http-proxy 解决跨域问题</a></li>
<li><a href="https://github.com/chimurai/http-proxy-middleware" target="_blank" rel="noopener">chimurai/http-proxy-middleware</a></li>
<li><a href="https://www.jb51.net/article/137608.htm" target="_blank" rel="noopener">详解 webpack-dev-server 的简单使用</a></li>
<li><a href="https://github.com/jantimon/html-webpack-plugin" target="_blank" rel="noopener">html-webpack-plugin</a></li>
<li><a href="https://www.jianshu.com/p/9248db0349fb" target="_blank" rel="noopener">webpack 使用 HtmlWebpackPlugin 进行 cdn 配置</a></li>
<li><a href="https://blog.csdn.net/const_ly/article/details/79788728" target="_blank" rel="noopener">CDN 是什么？使用 CDN 有什么优势？</a></li>
<li><a href="https://www.codercto.com/a/76835.html" target="_blank" rel="noopener">webpack4-06-开发、生产环境、动态 CDN 配置</a></li>
<li><a href="https://segmentfault.com/a/1190000008956069" target="_blank" rel="noopener">HTTP 强缓存和协商缓存</a></li>
<li><a href="https://www.jianshu.com/p/1744780ddda0" target="_blank" rel="noopener">Cache-Control 之 no-cache 和 max-age=0</a></li>
<li><a href="https://segmentfault.com/a/1190000019579621" target="_blank" rel="noopener">Commit message 代码提交规范</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html" target="_blank" rel="noopener">Commit message 和 Change log 编写指南</a></li>
<li><a href="https://www.cnblogs.com/zivxiaowei/p/10089201.html" target="_blank" rel="noopener">git commit 、CHANGELOG 和版本发布的标准自动化</a></li>
</ol>

        </div>

        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/前端工程化/"># 前端工程化</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2018/04/01/vue5/">vue项目中引入&使用国际化</a>
            
            
            <a class="next" rel="next" href="/2018/02/01/Js3/">正向代理&反向代理</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Echo | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>
</html>
